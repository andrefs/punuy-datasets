import { promises as fs } from "fs";
import { DatasetProfile } from "../lib/types";

const ignoreDS = ["bg100k"];
const datasetsSectionStart = "<!-- datasets-section-start -->";
const datasetsSectionEnd = "<!-- datasets-section-end -->";

interface DsInfo {
  id: string;
  name: string;
  year: number;
  lang: string;
  domain: string;
  measureTypes: string;
  reference: string;
  website: string;
}

async function getFilesInfo(folder: string) {
  const res = [];
  const fileNames = await getFileNames(folder);
  for (const fileName of fileNames) {
    const fileInfo = await getFileInfo(`${folder}/${fileName}`);
    res.push(fileInfo);
  }
  return res.sort((a, b) => a.year - b.year);
}

async function getFileNames(folder: string) {
  const res = [];
  try {
    const fileNames = await fs.readdir(folder);
    for (const fileName of fileNames) {
      if (
        !fileName.endsWith(".json") ||
        ignoreDS.some(ds => fileName.includes(ds))
      ) {
        continue;
      }
      res.push(fileName);
    }
  } catch (err) {
    process.exit(1);
  }
  return res;
}

async function getFileInfo(file: string) {
  const data = await fs.readFile(file, "utf-8");
  const all = JSON.parse(data) as DatasetProfile;
  const measTypes = all.metadata.measureTypes
    .sort()
    .map(m => m.substring(0, 3))
    .join("/");

  return {
    id: all.id,
    name: all.metadata.name,
    year: Number(all.metadata.date.substring(0, 4)),
    lang: all.metadata.languages.join("/"),
    domain: all.metadata.domain,
    measureTypes: measTypes,
    reference: all.metadata.papers[0].url,
    website: all.metadata.urls[0],
  } as DsInfo;
}

async function loadReadme() {
  const readme = await fs.readFile("README.md", "utf-8");
  return readme;
}

async function generateDatasetsSection() {
  const folder = "./profiles";
  const filesInfo = await getFilesInfo(folder);

  let res = `${datasetsSectionStart}\n`;
  res +=
    "<!-- Automatically generated by ./src/scripts/update-readme.ts -->\n\n";

  res += genTableHeader();
  for await (const info of filesInfo) {
    res += getTableRow(info);
  }
  res += `\n${datasetsSectionEnd}\n`;
  return res;
}

function getTableRow(dsInfo: DsInfo) {
  const fields = getTableFields(dsInfo);
  const res = `| ${fields.id} | ${fields.name} | ${fields.year} | ${fields.lang} | ${fields.domain} | ${fields.measureTypes} | ${fields.reference} | ${fields.website} | \n`;
  return res;
}

function getTableFields(dsInfo: DsInfo) {
  return {
    id: dsInfo.id,
    name: dsInfo.name,
    year: dsInfo.year,
    lang: dsInfo.lang,
    domain: dsInfo.domain,
    measureTypes: dsInfo.measureTypes,
    reference: dsInfo.reference ? `[link](${dsInfo.reference})` : "",
    website: dsInfo.website ? `[link](${dsInfo.website})` : "",
  };
}

function genTableHeader() {
  let res = `| ID | Name | Year | Language | Domain | Sim/Rel | Reference | Website | \n`;
  res += `| --- | --- | --- | --- | --- | --- |--- | --- |  \n`;
  return res;
}

async function main() {
  const readme = await loadReadme();
  const start = readme.indexOf(datasetsSectionStart);
  const end = readme.indexOf(datasetsSectionEnd) + datasetsSectionEnd.length;
  const datasetsSection = await generateDatasetsSection();
  const newReadme =
    readme.substring(0, start) +
    datasetsSection +
    readme.substring(end, readme.length);
  await fs.writeFile("README.md", newReadme);
}

main().then(() => console.log("Done!"));
