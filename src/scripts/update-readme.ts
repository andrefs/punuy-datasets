import { promises as fs } from "fs";
import { DatasetProfile } from "../lib/types";
import path from "path";

const ignoreDS: string[] = [
  //"bg100k"
];
const datasetsENSectionStart = "<!-- datasets-section-start#EN -->";
const datasetsENSectionEnd = "<!-- datasets-section-end#EN -->";
const datasetsPTSectionStart = "<!-- datasets-section-start#PT -->";
const datasetsPTSectionEnd = "<!-- datasets-section-end#PT -->";

/* eslint-disable @typescript-eslint/no-unused-vars */
interface DsInfo {
  id: string;
  name: string;
  year: number;
  lang: string;
  domain: string;
  relationTypes: string;
  reference: string;
  website: string;
}

async function getFilesInfo(folder: string, language: string) {
  const res = [];
  const dsFileNames = await getFileNames(folder);
  for (const dsFN of dsFileNames) {
    const fileInfo = await getFileInfo(path.join(dsFN));
    if (fileInfo.lang === language) {
      res.push(fileInfo);
    }
  }
  return res.sort((a, b) => a.year - b.year);
}

async function getFileNames(folder: string) {
  const res = [];
  let dsFolderNames;
  try {
    dsFolderNames = await fs.readdir(folder);
  } catch (err) {
    console.error("Error reading folder", folder, err);
    process.exit(1);
  }
  for (const dsFN of dsFolderNames) {
    if (ignoreDS.some(ds => dsFN.includes(ds))) {
      continue;
    }
    const fn = path.join(folder, dsFN, "dataset.json");
    try {
      await fs.access(fn);
      res.push(fn);
    } catch (err) {
      continue;
    }
  }
  return res;
}

async function getFileInfo(file: string) {
  const data = await fs.readFile(file, "utf-8");
  const all = JSON.parse(data) as DatasetProfile;
  const relTypes = all.metadata.relationTypes
    .sort()
    .map(m => m.substring(0, 3))
    .join("/");

  return {
    id: all.id,
    name: all.metadata.name,
    year: Number(all.metadata.date.substring(0, 4)),
    lang: all.metadata.languages.join("/"),
    domain: all.metadata.domain,
    relationTypes: relTypes,
    reference: all.metadata.papers?.[0]?.url,
    website: all.metadata.urls?.[0],
  } as DsInfo;
}

async function loadReadme() {
  const readme = await fs.readFile("README.md", "utf-8");
  return readme;
}

async function generateDatasetsSection(language: string) {
  const folder = "./profiles";
  const filesInfo = await getFilesInfo(folder, language);
  const dss =
    language === "en" ? datasetsENSectionStart : datasetsPTSectionStart;
  const dse = language === "en" ? datasetsENSectionEnd : datasetsPTSectionEnd;

  let res = `${dss}\n`;
  res +=
    "<!-- Automatically generated by ./src/scripts/update-readme.ts -->\n\n";

  res += genTableHeader();
  for await (const info of filesInfo) {
    res += getTableRow(info);
  }
  res += `\n${dse}`;
  return res;
}

function getTableRow(dsInfo: DsInfo) {
  const fields = getTableFields(dsInfo);
  const res = `| ${fields.id} | ${fields.name} | ${fields.year} | ${fields.domain} | ${fields.relationTypes} | ${fields.references.join(", ")} | \n`;
  return res;
}

function getTableFields(dsInfo: DsInfo) {
  const references = [];
  if (dsInfo.reference) {
    references.push(`[paper 📑](${dsInfo.reference})`);
  }
  if (dsInfo.website) {
    references.push(`[website 🌐](${dsInfo.website})`);
  }

  return {
    id: `[${dsInfo.id}](./profiles/${dsInfo.id})`,
    name: dsInfo.name,
    year: dsInfo.year,
    domain: dsInfo.domain,
    relationTypes: dsInfo.relationTypes,
    references,
  };
}

function genTableHeader() {
  let res = `| ID | Name | Year  | Domain | Sim/Rel | References \n`;
  res += `| --- | --- | --- | --- | --- | --- |  \n`;
  return res;
}

async function main() {
  const readme = await loadReadme();

  // english
  let start = readme.indexOf(datasetsENSectionStart);
  let end = readme.indexOf(datasetsENSectionEnd) + datasetsENSectionEnd.length;
  let datasetsSection = await generateDatasetsSection("en");

  let newReadme =
    readme.substring(0, start) +
    datasetsSection +
    readme.substring(end, readme.length);

  // portuguese
  start = readme.indexOf(datasetsPTSectionStart);
  end = readme.indexOf(datasetsPTSectionEnd) + datasetsPTSectionEnd.length;
  datasetsSection = await generateDatasetsSection("pt");

  newReadme =
    newReadme.substring(0, start) +
    datasetsSection +
    newReadme.substring(end, newReadme.length);

  await fs.writeFile("README.md", newReadme);
}

main().then(() => console.log("Done!"));
